/**  Крч, нашел важный прикол:
 *      При создании (new) объекта реализуются методы ТОЙ ШТУКИ, ЧТО СЛЕВА, пусть даже переопределенные в правой штуке!
 *      Вот как здесь:
 *          Parent newPar = new Child();
 *          - Реализуется методы Parent, в том числе и переопределенные в Child,
 *          но не реализуются собственные методы Child
 * */

package Interfaces;

public class Test {
    public static void main(String[] args) {
        int myNum = MyIntrf.SOME_NUM; // поля интерфейса могут пригодиться, чтобы получить инфу об интерфейcе внутри программы
        // Но сами переменные интерфейса, видимо, менять нельзя - только смотреть :(

        MyIntrf newAnimal = new Animal(); // теперь у объекта newAnimal будут доступны только методы MyIntrf, но не класса Animal
            // Блин в данном случае интерфейс поступает как паразит - пользуется другими классами, чтобы создавать свои объекты)

        // Интересно, а с наследованием эта штука работает?
        Parent newPar = new Child(); // Работает, но только в одну сторону: Родитель может иметь объект класса ребенка
         // но ребенок не может иметь объект класса родителя

        newPar.parMethod(); // при этом реализуются только методы Parent, но не Child

    }
}
