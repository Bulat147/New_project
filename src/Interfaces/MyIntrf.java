package Interfaces;

public interface MyIntrf {
    public int SOME_NUM = 76; /* В интерфейсах поля могут быть нужны, для сигнатуры внутренних методов,
                                        для получения инфы об интерфейсе внутри самой программы, но
                                        ГЛАВНОЕ - для использования в main, если он будет прописан внутри интерфейса;
                                     Но если их объявлять в интерфейсе - то сразу же и инициализировать, иначе - ошибка*/

    public static void main(String[] args) {
        System.out.println("А, так вот зачем нужны приватные методы и поля в интерфесах - на случай если мы " +
                "захотим точку входа в программу(main) зашить в Структуру интерфейса!");
        System.out.println(SOME_NUM); // А почему здесь ломается статический контекст??? Он не ломается, потому что...
                        // А-а-а, видимо потому, что объектов у интерфейса не бывает - только у классов-реализаторов!
                        // А значит все методы и поля в интерфейсе - уже (скрытно) STATIC, даже когда мы это явно не прописываем!
    }

    private void Method1(){
        System.out.println(SOME_NUM);  // вот опять скрытно статический контекст реализуется (значит дело не в main)
    }                           // Капец, в интерфейсах могут быть приватные методы - но только с телом(реализацией на месте);
                                // Вот для них-то и нужны поля интерфейса видимо

    public void Method2(); // а это уже обычный маневр - договор, что все классы-реализаторы этого интерфейса обязаны реализовать этот метод

}
